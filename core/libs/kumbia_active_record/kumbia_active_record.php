<?php

/**
 * KumbiaPHP web & app Framework
 *
 * LICENSE
 *
 * This source file is subject to the new BSD license that is bundled
 * with this package in the file LICENSE.
 *
 * @category   Kumbia
 * @package    ActiveRecord
 *
 * @copyright  Copyright (c) 2005 - 2019 KumbiaPHP Team (http://www.kumbiaphp.com)
 * @license    https://github.com/KumbiaPHP/KumbiaPHP/blob/master/LICENSE   New BSD License
 */
/**
 * @see Db
 */
require CORE_PATH . 'libs/db/db.php';

/**
 * ActiveRecordBase Class for Relational Object Mapping.
 *  *
 * Active Record is an approach to the problem of accessing data from a
 * Object-oriented database. A row in the
 * Database table (or view) is wrapped in a class,
 * so that unique rows of the database are associated
 * with objects of the programming language used.
 * When one of these objects is created, a row is added to
 * the database table. When the attributes of the
 * object, the database row is updated.
 *
 * Supported Properties:
 * $db = Database Engine Connection
 * $database = Database to which it connects, specified in databases.ini
 * $source = Table containing the table being mapped
 * $fields = List of Fields in the table that have been mapped
 * $count = Count of the last Result of a Select
 * $primary_key = List of columns that make up the primary key
 * $non_primary = List of columns that are not primary key
 * $not_null = List of fields that are not_null
 * $attributes_names = names of all fields that have been mapped
 * $debug = Indicates whether the SQL sent to the RDBM should be displayed on the screen
 * $logger = If it is different from false create a log using the Logger class
 * in library / kumbia / logger / logger.php, it creates a .txt file in logs / with all the
 * operations performed in ActiveRecord, if $ logger = "name" creates a
 * file with that name
 *
 * Unsupported Properties:
 * $ dynamic_update: The idea is that in the future ActiveRecord only
 * update the fields that have changed. (Developing)
 * $ dynamic_insert: Indicates if the insert values ​​are only those
 * That are not null. (Developing)
 * $ select_before_update: Requires a previous SELECT statement
 * UPDATE update to verify that the data has not been
 * Changed (In Development)
 * $ subselect: It will allow you to create a read-only ActiveRecord entity that
 * map the results of a select directly to an Object (In Development)
 *
 * @category   Kumbia
 */
class KumbiaActiveRecord
{
    //Supported
    /**
     * Resource connection to the database.
     *
     * @var DbBase
     */
    protected $db;
    /**
     * Database to which it connects.
     *
     * @var string
     */
    protected $database;
    /**
     * Schema where is the table.
     *
     * @var string
     */
    protected $schema;
    /**
     * Table used to perform the mapping.
     *
     * @var string
     */
    protected $source;
    /**
     * Number of results generated in the last query.
     *
     * @var int
     */
    protected $count;
    /**
     * Entity attribute names.
     *
     * @var array
     */
    protected $fields = array();
    /**
     * Primary keys of the entity.
     *
     * @var array
     */
    protected $primary_key = array();
    /**
     * Fields that are not primary key.
     *
     * @var array
     */
    protected $non_primary = array();
    /**
     * Fields that do not allow nulls.
     *
     * @var array
     */
    protected $not_null = array();
    /**
     * Fields that have default value.
     *
     * @var array
     */
    protected $_with_default = array();
    /**
     * Attribute names, is the same as fields.
     *
     * @var array
     */
    protected $alias = array();
    /**
     * Indicates if the class corresponds to a mapping of a view
     * in the database.
     *
     * @var bool
     */
    protected $is_view = false;
    /**
     * Indicates if the model is in debug mode.
     *
     * @var bool
     */
    protected $debug = false;
    /**
     * Indicates if the messages generated by the class will be logged.
     *
     * @var mixed
     */
    protected $logger = false;
    /**
     * Indicates whether the model data should be persisted.
     *
     * @var bool
     */
    protected $persistent = false;
    /**
     * Validations.
     *
     * inclusion_in: the field belongs to a set of elements
     * exclusion_of: the field does not belong to a set of elements
     * numericality_of: the field must be numeric
     * format_of: the field must match the regular expression
     * date_in: the field must be a valid date
     * email_in: the field must be an email
     * uniqueness_of: the field must be unique
     *
     * @var array
     * */
    protected $_validates = array(
        'inclusion_in' => array(), 'exclusion_of' => array(), 'numericality_of' => array(),
        'format_of' => array(), 'date_in' => array(), 'email_in' => array(), 'uniqueness_of' => array(),
    );
    /**
     * Fields ending in _in.
     *
     * @var array
     */
    protected $_in = array();
    /**
     * Fields ending in _at.
     *
     * @var array
     */
    protected $_at = array();
    /**
     * Variable to create a condition based on
     * where values.
     *
     * @var string
     */
    protected $_where_pk;
    /**
     * Indicates whether the Model metadata has already been obtained.
     *
     * @var bool
     */
    protected $_dumped = false;
    /**
     * Indicates if there is blocking over warnings when a property
     * of the model is not defined.
     *
     * @var bool
     */
    protected $_dump_lock = false;
    /**
     * Data types of model fields.
     *
     * @var array
     */
    protected $_data_type = array();
    /**
     * Relations to which it has a 1-1 cardinality.
     *
     * @var array
     */
    protected $_has_one = array();
    /**
     * Relations to which it has a 1-n cardinality.
     *
     * @var array
     */
    protected $_has_many = array();
    /**
     * Relations to which it has a 1-1 cardinality.
     *
     * @var array
     */
    protected $_belongs_to = array();
    /**
     * Relationships to which it has a cardinality n-n (many to many) or inverse 1-n.
     *
     * @var array
     */
    protected $_has_and_belongs_to_many = array();
    /**
     * Classes of which the current class is the parent.
     *
     * @var array
     */
    protected $parent_of = array();
    /**
     * Persistance Models Meta-data.
     */
    protected static $models = array();

    /**
     * Model Builder
     *
     * @param array $data
     */
    public function __construct($data = null)
    {
        $this->_model_name();
        /*
         * Initialize the model if there is initialize
         */
        if (method_exists($this, 'initialize')) {
            $this->initialize();
        }
        /*
         * Conecta a la bd
         * */
        $this->_connect();

        if ($data) {
            if (!is_array($data)) {
                $data = Util::getParams(func_get_args());
            }
            foreach ($this->fields as $field) {
                if (isset($data[$field])) {
                    $this->$field = $data[$field];
                }
            }
        }
    }

    /**
     * Gets the name of the relationship in the RDBM from the class name.
     */
    protected function _model_name()
    {
        if (!$this->source) {
            $this->source = Util::smallcase(get_class($this));
        }
    }

    /**
     * Publicly set the $source of the table.
     *
     * @param string $source
     */
    public function set_source($source)
    {
        $this->source = $source;
    }

    /**
     * Returns the current source.
     *
     * @return string
     */
    public function get_source()
    {
        return $this->source;
    }

    /**
     * Sets the database to use.
     *
     * @param string $database
     */
    public function set_database($database)
    {
        $this->database = $database;
    }

    /**
     * Returns the database.
     *
     * @return string
     */
    public function get_database()
    {
        return $this->database ?: Config::read('config')['application']['database'];
    }

    /**
     * Ask if ActiveRecord has already consulted metadata information
     * from the database or from the persistent registry.
     *
     * @return bool
     */
    public function is_dumped()
    {
        return $this->_dumped;
    }

    /**
     * Returns the records of the model to which it is associated.
     *
     * @param string $relmodel name of the associated model
     *
     * @return array|null|false if there is data it will return an array,
     *                          NULL if there is no associated data yet, and false if there is no association
     */
    protected function _get_relation_data($relmodel)
    {
        if (isset($this->_belongs_to[$relmodel])) {
            $relation = $this->_belongs_to[$relmodel];

            return (new $relation->model())->find_first($this->{$relation->fk});
        }
        if (isset($this->_has_one[$relmodel])) {
            $relation = $this->_has_one[$relmodel];
            if ($this->{$this->primary_key[0]}) {
                return (new $relation->model())->find_first("{$relation->fk}={$this->db->add_quotes($this->{$this->primary_key[0]})}");
            }

            return null;
        }
        if (isset($this->_has_many[$relmodel])) {
            $relation = $this->_has_many[$relmodel];
            if ($this->{$this->primary_key[0]}) {
                return (new $relation->model())->find("{$relation->fk}={$this->db->add_quotes($this->{$this->primary_key[0]})}");
            }

            return array();
        }
        if (isset($this->_has_and_belongs_to_many[$relmodel])) {
            $relation = $this->_has_and_belongs_to_many[$relmodel];
            $relation_model = self::get($relation->model);
            $source = ($this->schema ? "{$this->schema}." : null) . $this->source;
            $relation_source = ($relation_model->schema ? "{$relation_model->schema}." : null) . $relation_model->source;
            /*
             * Charge through which table the relationship will be made
             *
             */
            if (!isset($relation->through)) {
                if ($source > $relation_source) {
                    $relation->through = "{$this->source}_{$relation_source}";
                } else {
                    $relation->through = "{$relation_source}_{$this->source}";
                }
            } else {
                $through = explode('/', $relation->through);
                $relation->through = end($through);
            }
            if ($this->{$this->primary_key[0]}) {
                return $relation_model->find_all_by_sql("SELECT $relation_source.* FROM $relation_source, {$relation->through}, $source
                    WHERE {$relation->through}.{$relation->key} = {$this->db->add_quotes($this->{$this->primary_key[0]})}
                    AND {$relation->through}.{$relation->fk} = $relation_source.{$relation_model->primary_key[0]}
                    AND {$relation->through}.{$relation->key} = $source.{$this->primary_key[0]}
                    ORDER BY $relation_source.{$relation_model->primary_key[0]}");
            }

            return array();
        }

        return false; //if there is no association, it returns false.
    }

    /**
     * Validates that the values that are read from the ActiveRecord object are defined
     * previously or are attributes of the entity.
     *
     * @param string $property
     */
    public function __get($property)
    {
        if (!$this->_dump_lock) {
            if (!isset($this->$property)) {
                return $this->_get_relation_data($property);
            }
        }

        return $this->$property;
    }

    /**
     * Validates that the values that are assigned to the ActiveRecord object are defined
     * or are attributes of the entity.
     *
     * @param string $property
     * @param mixed  $value
     */
    public function __set($property, $value)
    {
        if (!$this->_dump_lock) {
            if (is_object($value) && is_subclass_of($value, 'KumbiaActiveRecord')) {
                if (array_key_exists($property, $this->_belongs_to)) {
                    $relation = $this->_belongs_to[$property];
                    $value->dump_model();
                    $this->{$relation->fk} = $value->{$value->primary_key[0]};

                    return;
                } elseif (array_key_exists($property, $this->_has_one)) {
                    $relation = $this->_has_one[$property];
                    $value->{$relation->fk} = $this->{$this->primary_key[0]};

                    return;
                }
            } elseif ($property == 'source') {
                $value = self::sql_item_sanitize($value);
            }
        }
        $this->$property = $value;
    }

    /**
     * Returns a value or a listing depending on the type of Relationship.
     */
    public function __call($method, $args = array())
    {
        if (substr($method, 0, 8) == 'find_by_') {
            $field = substr($method, 8);
            self::sql_item_sanitize($field);
            if (isset($args[0])) {
                $arg = array("conditions: $field = {$this->db->add_quotes($args[0])}");
                unset($args[0]);
            } else {
                $arg = array();
            }

            return call_user_func_array(array($this, 'find_first'), array_merge($arg, $args));
        }
        if (substr($method, 0, 9) == 'count_by_') {
            $field = substr($method, 9);
            self::sql_item_sanitize($field);
            if (isset($args[0])) {
                $arg = array("conditions: $field = {$this->db->add_quotes($args[0])}");
                unset($args[0]);
            } else {
                $arg = array();
            }

            return call_user_func_array(array($this, 'count'), array_merge($arg, $args));
        }
        if (substr($method, 0, 12) == 'find_all_by_') {
            $field = substr($method, 12);
            self::sql_item_sanitize($field);
            if (isset($args[0])) {
                $arg = array("conditions: $field = {$this->db->add_quotes($args[0])}");
                unset($args[0]);
            } else {
                $arg = array();
            }

            return call_user_func_array(array($this, 'find'), array_merge($arg, $args));
        }
        $model = preg_replace('/^get/', '', $method);
        $mmodel = Util::smallcase($model);
        if (($data = $this->_get_relation_data($mmodel)) !== false) {
            return $data;
        }
        if (method_exists($this, $method)) {
            call_user_func_array(array($this, $method), $args);
        } else {
            throw new KumbiaException("The method does not exist '$method' in ActiveRecord::" . get_class($this));
        }

        return $this->$method($args);
    }

    /**
     * It connects to the database and downloads the metadata if necessary.
     */
    protected function _connect()
    {
        if (!is_object($this->db)) {
            $this->db = Db::factory($this->database);
        }
        $this->db->debug = $this->debug;
        $this->db->logger = $this->logger;
        $this->dump();
    }

    /**
     * Load the metadata from the table.
     */
    public function dump_model()
    {
        $this->_connect();
    }

    /**
     * Check if the table defined in $this->source exists
     * in the database and dump it in dump_info.
     *
     * @return bool
     */
    protected function dump()
    {
        if ($this->_dumped) {
            return false;
        }
        if ($this->source) {
            $this->source = str_replace(';', '', strtolower($this->source));
        } else {
            $this->_model_name();
            if (!$this->source) {
                return false;
            }
        }
        $table = $this->source;
        $schema = $this->schema;
        if (!count(self::get_meta_data($this->source))) {
            $this->_dumped = true;
            $this->_dump_info($table, $schema);
            if (!count($this->primary_key)) {
                if (!$this->is_view) {
                    throw new KumbiaException("A primary key for the table has not been defined '$table' this makes it impossible to create the ActiveRecord for this entity");
                }
            }
        } else {
            if (!$this->is_dumped()) {
                $this->_dumped = true;
                $this->_dump_info($table, $schema);
            }
        }

        return true;
    }

    /**
     * Dump the information from the $table in the database
     * to arm the attributes and meta-data of the ActiveRecord.
     *
     * @param string $table
     *
     * @return bool
     */
    protected function _dump_info($table, $schema = '')
    {
        $this->_dump_lock = true;
        if (!count(self::get_meta_data($table))) {
            $meta_data = $this->db->describe_table($table, $schema);
            if ($meta_data) {
                self::set_meta_data($table, $meta_data);
            }
        }
        foreach (self::get_meta_data($table) as $field) {
            $this->fields[] = $field['Field'];
            $aliasAux = $field['Field'];
            if ($field['Key'] === 'PRI') {
                $this->primary_key[] = $field['Field'];
                $this->alias[$field['Field']] = 'Código';
            } else {
                $this->non_primary[] = $field['Field'];
            }
            /*
             * If it is indicated that it cannot be null, but a
             * default value, then it is not included in the list, since
             * when placing a default value, the field will never be null
             *
             */
            if ($field['Null'] == 'NO' && !(isset($field['Default']) && $field['Default'])) {
                $this->not_null[] = $field['Field'];
            }
            if (isset($field['Default']) && $field['Default']) {
                $this->_with_default[] = $field['Field'];
            }
            if ($field['Type']) {
                $this->_data_type[$field['Field']] = strtolower($field['Type']);
            }
            if (substr($field['Field'], strlen($field['Field']) - 3, 3) === '_at') {
                $this->_at[] = $field['Field'];
                $aliasAux = substr($field['Field'], 0, -3);
            }
            if (substr($field['Field'], strlen($field['Field']) - 3, 3) === '_in') {
                $this->_in[] = $field['Field'];
                $aliasAux = substr($field['Field'], 0, -3);
            }
            if (substr($field['Field'], strlen($field['Field']) - 3, 3) === '_id') {
                $aliasAux = substr($field['Field'], 0, -3);
            }
            //humanizing the alias
            $this->alias[$field['Field']] = ucwords(strtr($aliasAux, '_-', '  '));
        }
        $this->_dump_lock = false;

        return true;
    }

    /**
     * Returns an array of the fields of a Humanized table.
     *
     * @param $key
     *
     * @return array
     */
    public function get_alias($key = null)
    {
        if ($key === null) {
            return $this->alias;
        }
        if (isset($this->alias[$key])) {
            return $this->alias[$key];
        }
        throw new KumbiaException("The Alias could not be obtained, because the key: \"$key\" does not exist.");
    }

    /**
     * Assigns a new value to the alias given a key.
     *
     * @param string $key
     * @param string $value
     */
    public function set_alias($key, $value)
    {
        if (isset($this->alias[$key])) {
            $this->alias[$key] = $value;
        }
        throw new KumbiaException("The new value could not be assigned to the Alias, because the key: \"$key\" does not exist.");
    }

    /**
     * Commit a Transaction.
     *
     * @return success
     */
    public function commit()
    {
        return $this->db->commit();
    }

    /**
     * Rollback a Transaction.
     *
     * @return success
     */
    public function rollback()
    {
        return $this->db->rollback();
    }

    /**
     * Start a transaction in RDBM.
     *
     * @return success
     */
    public function begin()
    {
        $this->_connect(); //(true);
        return $this->db->begin();
    }

    /**
     * Find all records in this table using a SQL Statement.
     *
     * @param string $sqlQuery
     *
     * @return ActiveRecord Cursor
     */
    public function find_all_by_sql($sqlQuery)
    {
        $results = array();
        foreach ($this->db->fetch_all($sqlQuery) as $result) {
            $results[] = $this->dump_result($result);
        }

        return $results;
    }

    /**
     * Find a record in this table using a SQL Statement.
     *
     * @param string $sqlQuery
     *
     * @return ActiveRecord Cursor
     */
    public function find_by_sql($sqlQuery)
    {
        $row = $this->db->fetch_one($sqlQuery);
        if ($row !== false) {
            $this->dump_result_self($row);

            return $this->dump_result($row);
        } else {
            return false;
        }
    }

    /**
     * Execute a SQL Statement directly.
     *
     * @param string $sqlQuery
     *
     * @return int affected
     */
    public function sql($sqlQuery)
    {
        return $this->db->query($sqlQuery);
    }

    /**
     * Return Fist Record.
     *
     * Receive the same parameters as find
     *
     * @param mixed $what
     *
     * @return ActiveRecord Cursor
     */
    public function find_first($what = '')
    {
        $what = Util::getParams(func_get_args());
        $select = 'SELECT ';
        if (isset($what['columns'])) {
            $select .= self::sql_sanitize($what['columns']);
        } elseif (isset($what['distinct'])) {
            $select .= 'DISTINCT ';
            $select .= $what['distinct'] ? self::sql_sanitize($what['distinct']) : join(',', $this->fields);
        } else {
            $select .= join(',', $this->fields);
        }
        if ($this->schema) {
            $select .= " FROM {$this->schema}.{$this->source}";
        } else {
            $select .= " FROM {$this->source}";
        }
        $what['limit'] = 1;
        $select .= $this->convert_params_to_sql($what);
        $resp = false;
        $result = $this->db->fetch_one($select);
        if ($result) {
            $this->dump_result_self($result);
            $resp = $this->dump_result($result);
        }

        return $resp;
    }

    /**
     * Find data on Relational Map table.
     *
     * @param string $what
     *
     * @return ActiveRecord Cursor
     *
     * columns: columns to use
     * conditions: search conditions in WHERE
     * join: inclusion inner join or outer join
     * group: group field in GROUP BY
     * having: condition for the group
     * order: field for sort order ORDER BY
     * distinct: fields to make select distinct
     */
    public function find($what = '')
    {
        $what = Util::getParams(func_get_args());
        $select = 'SELECT ';
        if (isset($what['columns'])) {
            $select .= $what['columns'] ? self::sql_sanitize($what['columns']) : join(',', $this->fields);
        } elseif (isset($what['distinct'])) {
            $select .= 'DISTINCT ';
            $select .= $what['distinct'] ? self::sql_sanitize($what['distinct']) : join(',', $this->fields);
        } else {
            $select .= join(',', $this->fields);
        }
        if ($this->schema) {
            $select .= " FROM {$this->schema}.{$this->source}";
        } else {
            $select .= " FROM {$this->source}";
        }
        $select .= $this->convert_params_to_sql($what);
        $results = array();
        $all_results = $this->db->in_query($select);
        foreach ($all_results as $result) {
            $results[] = $this->dump_result($result);
        }
        $this->count = count($results, COUNT_NORMAL);
        if (isset($what[0]) && is_numeric($what[0])) {
            if (!isset($results[0])) {
                $this->count = 0;

                return false;
            }
            $this->dump_result_self($all_results[0]);
            $this->count = 1;

            return $results[0];
        }
        $this->count = count($results, COUNT_NORMAL);

        return $results;
    }

    /*
     * Build an SQL query with the $ what parameter, like this:
     * 	$what = Util::getParams(func_get_args());
     * 	$select = "SELECT * FROM Clientes";
     * 	$select.= $this->convert_params_to_sql($what);
     *
     * @param string|array $what
     * @return string
     */
    public function convert_params_to_sql($what = '')
    {
        $select = '';
        if (is_array($what)) {
            if (!isset($what['conditions'])) {
                if (!isset($this->primary_key[0]) && (isset($this->id) || $this->is_view)) {
                    $this->primary_key[0] = 'id';
                }
                self::sql_item_sanitize($this->primary_key[0]);
                if (isset($what[0])) {
                    if (is_numeric($what[0])) {
                        $what['conditions'] = "{$this->primary_key[0]} = " . (int) $what[0];
                    } else {
                        if ($what[0] == '') {
                            $what['conditions'] = "{$this->primary_key[0]} = ''";
                        } else {
                            $what['conditions'] = $what[0];
                        }
                    }
                }
            }
            if (isset($what['join'])) {
                $select .= " {$what['join']}";
            }
            if (isset($what['conditions'])) {
                $select .= " WHERE {$what['conditions']}";
            }
            if (isset($what['group'])) {
                $select .= " GROUP BY {$what['group']}";
            }
            if (isset($what['having'])) {
                $select .= " HAVING {$what['having']}";
            }
            if (isset($what['order'])) {
                self::sql_sanitize($what['order']);
                $select .= " ORDER BY {$what['order']}";
            }
            $limit_args = array($select);
            if (isset($what['limit'])) {
                array_push($limit_args, 'limit: ' . (int) $what['limit']);
            }
            if (isset($what['offset'])) {
                array_push($limit_args, 'offset: ' . (int) $what['offset']);
            }
            if (count($limit_args) > 1) {
                $select = call_user_func_array(array($this, 'limit'), $limit_args);
            }
        } else {
            if (strlen($what)) {
                if (is_numeric($what)) {
                    $select .= "WHERE {$this->primary_key[0]} = " . (int) $what[0];
                } else {
                    $select .= "WHERE $what";
                }
            }
        }

        return $select;
    }

    /*
     * Returns an appropriate LIMIT clause to the RDBMS used
     *
     * limit: maximum number of items to display
     * offset: from which item it starts to show
     *
     * @param string $sql select query
     * @return String LIMIT clause appropriate to the RDBMS used
     */
    public function limit($sql)
    {
        $args = func_get_args();

        return call_user_func_array(array($this->db, 'limit'), $args);
    }

    /**
     * Execute a SELECT DISTINCT.
     *
     * @param string $what
     *
     * @return array
     *
     * Supports parameters equal to find
     */
    public function distinct($what = '')
    {
        $what = Util::getParams(func_get_args());
        if ($this->schema) {
            $table = $this->schema . '.' . $this->source;
        } else {
            $table = $this->source;
        }
        if (empty($what['columns'])) {
            $what['columns'] = $what['0'];
        }
        $what['columns'] = self::sql_sanitize($what['columns']);
        $select = "SELECT DISTINCT {$what['columns']} FROM $table ";
        /*
         * Zero index is eliminated since by default convert_params_to_sql considers it as a condition in WHERE
         */
        unset($what[0]);
        $select .= $this->convert_params_to_sql($what);
        $results = array();
        foreach ($this->db->fetch_all($select) as $result) {
            $results[] = $result[0];
        }

        return $results;
    }

    /**
     * Run a query in the RDBM directly.
     *
     * @param string $sql
     *
     * @return resource
     */
    public static function static_select_one($sql)
    {
        $db = Db::factory();
        if (substr(ltrim($sql), 0, 7) != 'SELECT') {
            $sql = 'SELECT ' . $sql;
        }
        $num = $db->fetch_one($sql);

        return $num[0];
    }

    /**
     * Perform a row count.
     *
     * @param string $what
     *
     * @return int
     */
    public function count($what = '')
    {
        $what = Util::getParams(func_get_args());
        if ($this->schema) {
            $table = "{$this->schema}.{$this->source}";
        } else {
            $table = $this->source;
        }
        unset($what['order']);
        if (isset($what['distinct']) && $what['distinct']) {
            if (isset($what['group'])) {
                $select = "SELECT COUNT(*) FROM (SELECT DISTINCT {$what['distinct']} FROM $table ";
                $select .= $this->convert_params_to_sql($what);
                $select .= ') AS t ';
            } else {
                $select = "SELECT COUNT(DISTINCT {$what['distinct']}) FROM $table ";
                $select .= $this->convert_params_to_sql($what);
            }
        } else {
            $select = "SELECT COUNT(*) FROM $table ";
            $select .= $this->convert_params_to_sql($what);
        }
        $num = $this->db->fetch_one($select);

        return $num[0];
    }

    /**
     * Average the $what field.
     *
     * @param string $what
     *
     * @return array
     */
    public function average($what = '')
    {
        $what = Util::getParams(func_get_args());
        if (isset($what['column'])) {
            if (!$what['column']) {
                $what['column'] = $what[0];
            }
        } else {
            $what['column'] = $what[0];
        }
        unset($what[0]);
        self::sql_item_sanitize($what['column']);
        if ($this->schema) {
            $table = "{$this->schema}.{$this->source}";
        } else {
            $table = $this->source;
        }
        $select = "SELECT AVG({$what['column']}) FROM $table ";
        $select .= $this->convert_params_to_sql($what);
        $num = $this->db->fetch_one($select);

        return $num[0];
    }

    public function sum($what = '')
    {
        $what = Util::getParams(func_get_args());
        if (isset($what['column'])) {
            if (!$what['column']) {
                $what['column'] = $what[0];
            }
        } else {
            $what['column'] = $what[0];
        }
        unset($what[0]);
        self::sql_item_sanitize($what['column']);
        if ($this->schema) {
            $table = "{$this->schema}.{$this->source}";
        } else {
            $table = $this->source;
        }
        $select = "SELECT SUM({$what['column']}) FROM $table ";
        $select .= $this->convert_params_to_sql($what);
        $num = $this->db->fetch_one($select);

        return $num[0];
    }

    /**
     * Find the maximum value for the $ what field.
     *
     * @param string $what
     *
     * @return mixed
     */
    public function maximum($what = '')
    {
        $what = Util::getParams(func_get_args());
        if (isset($what['column'])) {
            if (!$what['column']) {
                $what['column'] = $what[0];
            }
        } else {
            $what['column'] = $what[0];
        }
        unset($what[0]);
        self::sql_item_sanitize($what['column']);
        if ($this->schema) {
            $table = "{$this->schema}.{$this->source}";
        } else {
            $table = $this->source;
        }
        $select = "SELECT MAX({$what['column']}) FROM $table ";
        $select .= $this->convert_params_to_sql($what);
        $num = $this->db->fetch_one($select);

        return $num[0];
    }

    /**
     * Find the minimum value for the $ what field.
     *
     * @param string $what
     *
     * @return mixed
     */
    public function minimum($what = '')
    {
        $what = Util::getParams(func_get_args());
        if (isset($what['column'])) {
            if (!$what['column']) {
                $what['column'] = $what[0];
            }
        } else {
            $what['column'] = $what[0];
        }
        unset($what[0]);
        self::sql_item_sanitize($what['column']);
        if ($this->schema) {
            $table = "{$this->schema}.{$this->source}";
        } else {
            $table = $this->source;
        }
        $select = "SELECT MIN({$what['column']}) FROM $table ";
        $select .= $this->convert_params_to_sql($what);
        $num = $this->db->fetch_one($select);

        return $num[0];
    }

    /**
     * Make a direct count using $sql.
     *
     * @param string $sqlQuery
     *
     * @return mixed
     */
    public function count_by_sql($sqlQuery)
    {
        $num = $this->db->fetch_one($sqlQuery);

        return $num[0];
    }

    /**
     * Match the values ​​of a database result
     * in a new object with its corresponding
     * class attributes.
     *
     * @param array $result
     *
     * @return ActiveRecord
     */
    public function dump_result($result)
    {
        $obj = clone $this;
        /*
         * Check if the class is the parent of another and create the correct type
         */
        if (isset($result['type'])) {
            if (in_array($result['type'], $this->parent_of)) {
                if (class_exists($result['type'])) {
                    $obj = new $result['type']();
                    unset($result['type']);
                }
            }
        }
        $this->_dump_lock = true;
        if (is_array($result)) {
            foreach ($result as $k => $r) {
                if (!is_numeric($k)) {
                    if (!is_object($r)) {
                        $obj->$k = stripslashes($r);
                    } else {
                        $obj->$k = $r->load();
                    }
                }
            }
        }
        $this->_dump_lock = false;

        return $obj;
    }

    /**
     * Match the values ​​of a database result
     * with their corresponding class attributes.
     *
     * @param array $result
     *
     * @return ActiveRecord
     */
    public function dump_result_self($result)
    {
        $this->_dump_lock = true;
        if (is_array($result)) {
            foreach ($result as $k => $r) {
                if (!is_numeric($k)) {
                    if (!is_object($r)) {
                        $this->$k = is_array($r) ? $r : stripslashes($r);
                    } else {
                        $this->$k = $r->load();
                    }
                }
            }
        }
        $this->_dump_lock = false;
    }

    /**
     * Create a new record using the data from $ _REQUEST.
     *
     * @param string $form, equivalente a $_REQUEST[$form]
     *
     * @return bool success
     *
     * @deprecated Is not safe
     */
    public function create_from_request($form = null)
    {
        if (!$form) {
            $form = $this->source;
        }

        return $this->create($_REQUEST[$form]);
    }

    /**
     * Saves a new Row using values from $_REQUEST.
     *
     * @param string $form form name for request, equivalent to $_REQUEST[$form]
     *
     * @return bool success
     *
     * @deprecated Is not safe
     */
    public function save_from_request($form = null)
    {
        if (!$form) {
            $form = $this->source;
        }

        return $this->save($_REQUEST[$form]);
    }

    /**
     * Updates a Row using values from $_REQUEST.
     *
     * @param string $form form name for request, equivalent to $_REQUEST[$form]
     *
     * @return bool|null success
     */
    public function update_from_request($form = null)
    {
        if (!$form) {
            $form = $this->source;
        }

        return $this->update($_REQUEST[$form]);
    }

    /**
     * Creates a new Row in map table.
     *
     * @param mixed $values
     *
     * @return bool success
     */
    public function create()
    {
        if (func_num_args() > 0) {
            $params = Util::getParams(func_get_args());
            $values = (isset($params[0]) && is_array($params[0])) ? $params[0] : $params;
            foreach ($this->fields as $field) {
                if (isset($values[$field])) {
                    $this->$field = $values[$field];
                }
            }
        }
        if ($this->primary_key[0] == 'id') {
            $this->id = null;
        }

        return $this->save();
    }

    /**
     * Check if a certain record exists or not
     * in the database entity.
     *
     * @return bool
     */
    public function exists($where_pk = '')
    {
        if ($this->schema) {
            $table = "{$this->schema}.{$this->source}";
        } else {
            $table = $this->source;
        }
        if (!$where_pk) {
            $where_pk = array();
            foreach ($this->primary_key as $key) {
                if ($this->$key) {
                    $where_pk[] = " $key = '{$this->$key}'";
                }
            }
            if (count($where_pk)) {
                $this->_where_pk = join(' AND ', $where_pk);
            } else {
                return 0;
            }
            $query = "SELECT COUNT(*) FROM $table WHERE {$this->_where_pk}";
        } else {
            if (is_numeric($where_pk)) {
                $query = "SELECT COUNT(*) FROM $table WHERE {$this->primary_key[0]} = '$where_pk'";
            } else {
                $query = "SELECT COUNT(*) FROM $table WHERE $where_pk";
            }
        }
        $num = $this->db->fetch_one($query);

        return $num[0];
    }

    /**
     * Saves Information on the ActiveRecord Properties.
     *
     * @param array $values array of values ​​to load
     *
     * @return bool success
     */
    public function save($values = null)
    {
        if ($values) {
            if (!is_array($values)) {
                $values = Util::getParams(func_get_args());
            }
            foreach ($this->fields as $field) {
                if (isset($values[$field])) {
                    $this->$field = $values[$field];
                }
            }
        }
        $ex = $this->exists();
        if ($this->schema) {
            $table = $this->schema . '.' . $this->source;
        } else {
            $table = $this->source;
        }
        //Run Validation Callbacks Before
        if (method_exists($this, 'before_validation')) {
            if ($this->before_validation() == 'cancel') {
                return false;
            }
        } else {
            if (isset($this->before_validation)) {
                $method = $this->before_validation;
                if ($this->$method() == 'cancel') {
                    return false;
                }
            }
        }
        if (!$ex) {
            if (method_exists($this, 'before_validation_on_create')) {
                if ($this->before_validation_on_create() == 'cancel') {
                    return false;
                }
            } else {
                if (isset($this->before_validation_on_create)) {
                    $method = $this->before_validation_on_create;
                    if ($this->$method() == 'cancel') {
                        return false;
                    }
                }
            }
        }
        if ($ex) {
            if (method_exists($this, 'before_validation_on_update')) {
                if ($this->before_validation_on_update() == 'cancel') {
                    return false;
                }
            } else {
                if (isset($this->before_validation_on_update)) {
                    $method = $this->before_validation_on_update;
                    if ($this->$method() == 'cancel') {
                        return false;
                    }
                }
            }
        }
        /*
         * Validation validates_presence
         *
         */
        if (isset($this->_validates['presence_of'])) {
            foreach ($this->_validates['presence_of'] as $f => $opt) {
                if (isset($this->$f) && (is_null($this->$f) || $this->$f === '')) {
                    if (!$ex && $f == $this->primary_key[0]) {
                        continue;
                    }
                    if (isset($opt['message'])) {
                        Flash::error($opt['message']);

                        return false;
                    } else {
                        $field = isset($opt['field']) ? $opt['field'] : $f;
                        Flash::error("Error: The Field $field It can not be null");

                        return false;
                    }
                }
            }
        }
        /*
         * We remind you that those that have default values ​​do not appear here,
         * but nevertheless it must be pending to validate in the other verifications
         * the null fields, since in these if the field is null, it really refers to a field that
         * debe tomar el valor por defecto
         *
         */
        foreach ($this->not_null as $f) {
            if (in_array($f, $this->_with_default)) {
                continue;
            }
            if (!isset($this->$f) || is_null($this->$f) || $this->$f == '') {
                if (!$ex && $f == $this->primary_key[0]) {
                    continue;
                }
                if (!$ex && in_array($f, $this->_at)) {
                    continue;
                }
                if ($ex && in_array($f, $this->_in)) {
                    continue;
                }
                Flash::error("Error: The Field $f It can not be null");

                return false;
            }
        }
        /*
         * Validation validates_length
         *
         */
        if (isset($this->_validates['length_of'])) {
            foreach ($this->_validates['length_of'] as $f => $opt) {
                if (isset($this->$f) && !is_null($this->$f) && $this->$f != '') {
                    $field = isset($opt['field']) ? $opt['field'] : $f;
                    if (strlen($this->$f) < $opt['min']) {
                        if (isset($opt['too_short'])) {
                            Flash::error($opt['too_short']);
                        } else {
                            Flash::error("Error: The Field $field must have at least $opt[min] characters");
                        }

                        return false;
                    }
                    if (strlen($this->$f) > $opt['max']) {
                        if (isset($opt['too_long'])) {
                            Flash::error($opt['too_long']);
                        } else {
                            Flash::error("Error: The Field $field must have at most $opt[max] characters");
                        }

                        return false;
                    }
                }
            }
        }
        /*
         * Validation validates_inclusion
         *
         */
        foreach ($this->_validates['inclusion_in'] as $f => $opt) {
            if (isset($this->$f) && !is_null($this->$f) && $this->$f != '') {
                if (!in_array($this->$f, $opt['list'])) {
                    if (isset($opt['message'])) {
                        Flash::error($opt['message']);
                    } else {
                        $field = isset($opt['field']) ? $opt['field'] : $f;
                        Flash::error("$field must have a value between (" . join(',', $opt['list']) . ')');
                    }

                    return false;
                }
            }
        }
        /*
         * Validation validates_exclusion
         *
         */
        foreach ($this->_validates['exclusion_of'] as $f => $opt) {
            if (isset($this->$f) && !is_null($this->$f) && $this->$f != '') {
                if (in_array($this->$f, $opt['list'])) {
                    if (isset($opt['message'])) {
                        Flash::error($opt['message']);
                    } else {
                        $field = isset($opt['field']) ? $opt['field'] : $f;
                        Flash::error("$field must not have a value between (" . join(',', $opt['list']) . ')');
                    }

                    return false;
                }
            }
        }
        /*
         * Validation validates_numericality
         *
         */
        foreach ($this->_validates['numericality_of'] as $f => $opt) {
            if (isset($this->$f) && !is_null($this->$f) && $this->$f != '') {
                if (!is_numeric($this->$f)) {
                    if (isset($opt['message'])) {
                        Flash::error($opt['message']);
                    } else {
                        $field = isset($opt['field']) ? $opt['field'] : $f;
                        Flash::error("$field must have a numerical value");
                    }

                    return false;
                }
            }
        }
        /*
         * Validation validates_format
         *
         */
        foreach ($this->_validates['format_of'] as $f => $opt) {
            if (isset($this->$f) && !is_null($this->$f) && $this->$f != '') {
                if (!filter_var($this->$f, FILTER_VALIDATE_REGEXP, array('options' => array('regexp' => $opt['pattern'])))) {
                    if (isset($opt['message'])) {
                        Flash::error($opt['message']);
                    } else {
                        $field = isset($opt['field']) ? $opt['field'] : $f;
                        Flash::error("Wrong format for$field");
                    }

                    return false;
                }
            }
        }
        /*
         * Validation validates_date
         *
         */
        foreach ($this->_validates['date_in'] as $f => $opt) {
            if (isset($this->$f) && !is_null($this->$f) && $this->$f != '') {
                if (!filter_var($this->$f, FILTER_VALIDATE_REGEXP, array('options' => array('regexp' => "/^\d{4}[-\/](0[1-9]|1[012])[-\/](0[1-9]|[12][0-9]|3[01])$/")))) {
                    if (isset($opt['message'])) {
                        Flash::error($opt['message']);
                    } else {
                        $field = isset($opt['field']) ? $opt['field'] : $f;
                        Flash::error("Wrong date format for $field");
                    }

                    return false;
                }
            }
        }
        /*
         * Validation validates_email
         *
         */
        foreach ($this->_validates['email_in'] as $f => $opt) {
            if (isset($this->$f) && !is_null($this->$f) && $this->$f != '') {
                if (!filter_var($this->$f, FILTER_VALIDATE_EMAIL)) {
                    if (isset($opt['message'])) {
                        Flash::error($opt['message']);
                    } else {
                        $field = isset($opt['field']) ? $opt['field'] : $f;
                        Flash::error("Wrong email format in the field $field");
                    }

                    return false;
                }
            }
        }
        /**
         * Validation validates_uniqueness.
         */
        // patch so you don't take your own record
        // when validating unique fields, because if you take it into account
        // will launch validation error because a record already exists
        // with equal value in the unique field.
        $and_condition = $ex ? " AND {$this->primary_key[0]} != '{$this->{$this->primary_key[0]}}'" : '';
        foreach ($this->_validates['uniqueness_of'] as $f => $opt) {
            if (isset($this->$f) && !is_null($this->$f) && $this->$f != '') {
                $result = $this->db->fetch_one("SELECT COUNT(*) FROM $table WHERE $f = {$this->db->add_quotes($this->$f)} $and_condition");
                if ($result[0]) {
                    if (isset($opt['message'])) {
                        Flash::error($opt['message']);
                    } else {
                        $field = isset($opt['field']) ? $opt['field'] : $f;
                        Flash::error("The value'{$this->$f}' already exists for the field $field");
                    }

                    return false;
                }
            }
        }
        //Run Validation Callbacks After
        if (!$ex) {
            if (method_exists($this, 'after_validation_on_create')) {
                if ($this->after_validation_on_create() == 'cancel') {
                    return false;
                }
            } else {
                if (isset($this->after_validation_on_create)) {
                    $method = $this->after_validation_on_create;
                    if ($this->$method() == 'cancel') {
                        return false;
                    }
                }
            }
        }
        if ($ex) {
            if (method_exists($this, 'after_validation_on_update')) {
                if ($this->after_validation_on_update() == 'cancel') {
                    return false;
                }
            } else {
                if (isset($this->after_validation_on_update)) {
                    $method = $this->after_validation_on_update;
                    if ($this->$method() == 'cancel') {
                        return false;
                    }
                }
            }
        }
        if (method_exists($this, 'after_validation')) {
            if ($this->after_validation() == 'cancel') {
                return false;
            }
        } else {
            if (isset($this->after_validation)) {
                $method = $this->after_validation;
                if ($this->$method() == 'cancel') {
                    return false;
                }
            }
        }
        // Run Before Callbacks
        if (method_exists($this, 'before_save')) {
            if ($this->before_save() == 'cancel') {
                return false;
            }
        } else {
            if (isset($this->before_save)) {
                $method = $this->before_save;
                if ($this->$method() == 'cancel') {
                    return false;
                }
            }
        }
        if ($ex) {
            if (method_exists($this, 'before_update')) {
                if ($this->before_update() == 'cancel') {
                    return false;
                }
            } else {
                if (isset($this->before_update)) {
                    $method = $this->before_update;
                    if ($this->$method() == 'cancel') {
                        return false;
                    }
                }
            }
        }
        if (!$ex) {
            if (method_exists($this, 'before_create')) {
                if ($this->before_create() == 'cancel') {
                    return false;
                }
            } else {
                if (isset($this->before_create)) {
                    $method = $this->before_create;
                    if ($this->$method() == 'cancel') {
                        return false;
                    }
                }
            }
        }
        $environment = Config::read('databases');
        $config = $environment[$this->get_database()];
        if ($ex) {
            $fields = array();
            $values = array();
            foreach ($this->non_primary as $np) {
                $np = self::sql_item_sanitize($np);
                if (in_array($np, $this->_in)) {
                    if ($config['type'] == 'oracle') {
                        $this->$np = date('Y-m-d');
                    } else {
                        $this->$np = date('Y-m-d G:i:s');
                    }
                }
                if (isset($this->$np)) {
                    $fields[] = $np;
                    if (is_null($this->$np) || $this->$np == '' && $this->$np != '0') {
                        $values[] = 'NULL';
                    } else {
                        /*
                         * You must specify the date format in Oracle
                         */
                        if ($this->_data_type[$np] == 'date' && $config['type'] == 'oracle') {
                            $values[] = 'TO_DATE(' . $this->db->add_quotes($this->$np) . ", 'YYYY-MM-DD')";
                        } else {
                            $values[] = $this->db->add_quotes($this->$np);
                        }
                    }
                }
            }
            $val = $this->db->update($table, $fields, $values, $this->_where_pk);
        } else {
            $fields = array();
            $values = array();
            foreach ($this->fields as $field) {
                if ($field != $this->primary_key[0] || $this->{$this->primary_key[0]}) {
                    if (in_array($field, $this->_at)) {
                        if ($config['type'] == 'oracle') {
                            $this->$field = date('Y-m-d');
                        } else {
                            $this->$field = date('Y-m-d G:i:s');
                        }
                    }
                    if (in_array($field, $this->_in)) {
                        unset($this->$field);
                    }
                    if (isset($this->$field) && $this->$field !== '' && $this->$field !== null) {
                        $fields[] = self::sql_sanitize($field);

                        if (($this->_data_type[$field] == 'datetime' || $this->_data_type[$field] == 'date') && ($config['type'] == 'mysql' || $config['type'] == 'mysqli')) {
                            $values[] = $this->db->add_quotes(date('Y-m-d G:i:s', strtotime($this->$field)));
                        } elseif ($this->_data_type[$field] == 'date' && $config['type'] == 'oracle') {
                            //You must specify the date format in Oracle
                            $values[] = 'TO_DATE(' . $this->db->add_quotes($this->$field) . ", 'YYYY-MM-DD')";
                        } else {
                            $values[] = $this->db->add_quotes($this->$field);
                        }
                    } elseif (in_array($field, $this->_with_default)) {
                        $fields[] = self::sql_sanitize($field);
                        $values[] = 'DEFAULT';
                    } else {
                        $fields[] = self::sql_sanitize($field);
                        $values[] = 'NULL';
                    }
                } else {
                    /*
                     * Autonomic fields in Oracle must use auxiliary sequencing
                     */
                    if ($config['type'] == 'oracle') {
                        if (!$this->id) {
                            $fields[] = 'id';
                            $values[] = $this->source . '_id_seq.NEXTVAL';
                        }
                    }
                    if ($config['type'] == 'informix') {
                        if (!$this->id) {
                            $fields[] = 'id';
                            $values[] = 0;
                        }
                    }
                }
            }
            $val = $this->db->insert($table, $values, $fields);
        }
        if (!isset($config['pdo']) && $config['type'] == 'oracle') {
            $this->commit();
        }
        if (!$ex) {
            //$this->db->logger = true;
            $m = $this->db->last_insert_id($table, $this->primary_key[0]);
            $this->find_first($m);
        }
        if ($val) {
            if ($ex) {
                if (method_exists($this, 'after_update')) {
                    if ($this->after_update() == 'cancel') {
                        return false;
                    }
                } else {
                    if (isset($this->after_update)) {
                        $method = $this->after_update;
                        if ($this->$method() == 'cancel') {
                            return false;
                        }
                    }
                }
            }
            if (!$ex) {
                if (method_exists($this, 'after_create')) {
                    if ($this->after_create() == 'cancel') {
                        return false;
                    }
                } else {
                    if (isset($this->after_create)) {
                        $method = $this->after_create;
                        if ($this->$method() == 'cancel') {
                            return false;
                        }
                    }
                }
            }
            if (method_exists($this, 'after_save')) {
                if ($this->after_save() == 'cancel') {
                    return false;
                }
            } else {
                if (isset($this->after_save)) {
                    $method = $this->after_save;
                    if ($this->$method() == 'cancel') {
                        return false;
                    }
                }
            }

            return $val;
        } else {
            return false;
        }
    }

    /**
     * Find All data in the Relational Table.
     *
     * @param string $field
     * @param string $value
     *
     * @return ActiveRecord Cursor
     */
    public function find_all_by($field, $value)
    {
        self::sql_item_sanitize($field);

        return $this->find("conditions: $field = {$this->db->add_quotes($value)}");
    }

    /**
     * Updates Data in the Relational Table.
     *
     * @param mixed $values
     *
     * @return bool|null sucess
     */
    public function update()
    {
        if (func_num_args() > 0) {
            $params = Util::getParams(func_get_args());
            $values = (isset($params[0]) && is_array($params[0])) ? $params[0] : $params;
            foreach ($this->fields as $field) {
                if (isset($values[$field])) {
                    $this->$field = $values[$field];
                }
            }
        }
        if ($this->exists()) {
            if (method_exists($this, 'before_change')) {
                $obj = clone $this;
                if ($this->before_change($obj->find($this->{$this->primary_key[0]})) == 'cancel') {
                    return false;
                }
                unset($obj);
            }
            if ($this->save()) {
                if (method_exists($this, 'after_change')) {
                    if ($this->after_change($this) == 'cancel') {
                        return false;
                    }
                }

                return true;
            }
        } else {
            Flash::error('Unable to update because the record does not exist');

            return false;
        }
    }

    /**
     * Deletes data from Relational Map Table.
     *
     * @param mixed $what
     */
    public function delete($what = '')
    {
        if (func_num_args() > 1) {
            $what = Util::getParams(func_get_args());
        }
        if ($this->schema) {
            $table = $this->schema . '.' . $this->source;
        } else {
            $table = $this->source;
        }
        $conditions = '';
        if (is_array($what)) {
            if ($what['conditions']) {
                $conditions = $what['conditions'];
            }
        } else {
            if (is_numeric($what)) {
                self::sql_sanitize($this->primary_key[0]);
                $conditions = "{$this->primary_key[0]} = '$what'";
            } else {
                if ($what) {
                    $conditions = $what;
                } else {
                    self::sql_sanitize($this->primary_key[0]);
                    $conditions = "{$this->primary_key[0]} = '{$this->{$this->primary_key[0]}}'";
                }
            }
        }
        if (method_exists($this, 'before_delete')) {
            if ($this->{$this->primary_key[0]}) {
                $this->find($this->{$this->primary_key[0]});
            }
            if ($this->before_delete() == 'cancel') {
                return false;
            }
        } else {
            if (isset($this->before_delete)) {
                if ($this->{$this->primary_key[0]}) {
                    $this->find($this->{$this->primary_key[0]});
                }
                $method = $this->before_delete;
                if ($this->$method() == 'cancel') {
                    return false;
                }
            }
        }
        $val = $this->db->delete($table, $conditions);
        if ($val) {
            if (method_exists($this, 'after_delete')) {
                if ($this->after_delete() == 'cancel') {
                    return false;
                }
            } else {
                if (isset($this->after_delete)) {
                    $method = $this->after_delete;
                    if ($this->$method() == 'cancel') {
                        return false;
                    }
                }
            }
        }

        return $val;
    }

    /**
     * Update all entity attributes
     * $Clientes->update_all("estado='A', fecha='2005-02-02'", "id>100");
     * $Clientes->update_all("estado='A', fecha='2005-02-02'", "id>100", "limit: 10");.
     *
     * @param string $values
     */
    public function update_all($values)
    {
        $params = array();
        if ($this->schema) {
            $table = $this->schema . '.' . $this->source;
        } else {
            $table = $this->source;
        }
        if (func_num_args() > 1) {
            $params = Util::getParams(func_get_args());
        }
        if (!isset($params['conditions']) || !$params['conditions']) {
            if (isset($params[1])) {
                $params['conditions'] = $params[1];
            } else {
                $params['conditions'] = '';
            }
        }
        if ($params['conditions']) {
            $params['conditions'] = ' WHERE ' . $params['conditions'];
        }
        $sql = "UPDATE $table SET $values {$params['conditions']}";
        $limit_args = array($sql);
        if (isset($params['limit'])) {
            array_push($limit_args, "limit: $params[limit]");
        }
        if (isset($params['offset'])) {
            array_push($limit_args, "offset: $params[offset]");
        }
        if (count($limit_args) > 1) {
            $sql = call_user_func_array(array($this, 'limit'), $limit_args);
        }
        $environment = Config::read('databases');
        $config = $environment[$this->get_database()];
        if (!isset($config->pdo) || !$config->pdo) {
            if ($config['type'] == 'informix') {
                $this->db->set_return_rows(false);
            }
        }

        return $this->db->query($sql);
    }

    /**
     * Delete All data from Relational Map Table.
     *
     * @param string $conditions
     *
     * @return bool
     */
    public function delete_all($conditions = '')
    {
        //$limit = '';
        if ($this->schema) {
            $table = $this->schema . '.' . $this->source;
        } else {
            $table = $this->source;
        }
        if (func_num_args() > 1) {
            $params = Util::getParams(func_get_args());
            $limit_args = array($select);
            if (isset($params['limit'])) {
                array_push($limit_args, "limit: $params[limit]");
            }
            if (isset($params['offset'])) {
                array_push($limit_args, "offset: $params[offset]");
            }
            if (count($limit_args) > 1) {
                $select = call_user_func_array(array($this, 'limit'), $limit_args);
            }
        }

        return $this->db->delete($table, $conditions);
    }

    /**
     * *********************************************************************************
     * Debug Methods
     * *********************************************************************************.
     */

    /**
     * Print a human version of the field values
     * of the model in a single line.
     */
    public function inspect()
    {
        $inspect = array();
        foreach ($this->fields as $field) {
            if (!is_array($field)) {
                $inspect[] = "$field: {$this->$field}";
            }
        }

        return join(', ', $inspect);
    }

    /**
     * *********************************************************************************
     * Validation Methods
     * *********************************************************************************.
     */

    /**
     * Validate that the field is not null.
     *
     * @param string $field  field to validate
     * @param array  $params additional parameters
     *
     * message: message to show
     * field: field name to display in the message
     */
    protected function validates_presence_of($field, $params = array())
    {
        if (is_string($params)) {
            $params = Util::getParams(func_get_args());
        }
        $this->_validates['presence_of'][$field] = $params;
    }

    /**
     * Validate the size of certain fields before inserting
     * or update.
     *
     * @params string $field field to validate
     *
     * @param int   $max    maximum value
     * @param int   $min    minimum value
     * @param array $params additional parameters
     *
     * too_short: message to show when very short
     * too_long: message to show when very long
     * field: field name to display in the message
     */
    protected function validates_length_of($field, $max, $min = 0, $params = array())
    {
        if (is_string($params)) {
            $params = Util::getParams(func_get_args());
        }
        $this->_validates['length_of'][$field] = $params;
        $this->_validates['length_of'][$field]['min'] = $min;
        $this->_validates['length_of'][$field]['max'] = $max;
    }

    /**
     * Validates that the field is among the values in a list
     * before inserting or updating.
     *
     * @param string $field field to validate
     * @param array  $list
     *
     * message: message to show
     * field: field name to display in the message
     */
    protected function validates_inclusion_in($field, $list, $params = array())
    {
        if (is_string($params)) {
            $params = Util::getParams(func_get_args());
        }
        $this->_validates['inclusion_in'][$field] = $params;
        $this->_validates['inclusion_in'][$field]['list'] = $list;
    }

    /**
     * Validates that the field is not among the values ​​in a list
     * before inserting or updating.
     *
     * @param string $field field to validate
     * @param array  $list
     *
     * message: message to show
     * field: field name to display in the message
     */
    protected function validates_exclusion_of($field, $list, $params = array())
    {
        if (is_string($params)) {
            $params = Util::getParams(func_get_args());
        }
        $this->_validates['exclusion_of'][$field] = $params;
        $this->_validates['exclusion_of'][$field]['list'] = $list;
    }

    /**
     * Validates that the field has a certain format according to a regular expression
     * before inserting or updating.
     *
     * @param string $field   field to validate
     * @param string $pattern regular expression for preg_match
     *
     * message: message to display
     * field: name of the field to display in the message
     */
    protected function validates_format_of($field, $pattern, $params = array())
    {
        if (is_string($params)) {
            $params = Util::getParams(func_get_args());
        }
        $this->_validates['format_of'][$field] = $params;
        $this->_validates['format_of'][$field]['pattern'] = $pattern;
    }

    /**
     * Validates that certain attributes have a numerical value
     * before inserting or updating.
     *
     * @param string $field campo a validar
     *
     * message: message to display
     * field: name of the field to display in the message
     */
    protected function validates_numericality_of($field, $params = array())
    {
        if (is_string($params)) {
            $params = Util::getParams(func_get_args());
        }
        $this->_validates['numericality_of'][$field] = $params;
    }

    /**
     * Validates that certain attributes have a correct e-mail format
     * before inserting or updating.
     *
     * @param string $field campo a validar
     *
     * message: message to display
     * field: name of the field to display in the message
     */
    protected function validates_email_in($field, $params = array())
    {
        if (is_string($params)) {
            $params = Util::getParams(func_get_args());
        }
        $this->_validates['email_in'][$field] = $params;
    }

    /**
     * Validates that certain attributes have a unique value before
     * of inserting or updating.
     *
     * @param string $field field to validate
     *
     * message: message to display
     * field: name of the field to display in the message
     */
    protected function validates_uniqueness_of($field, $params = array())
    {
        if (is_string($params)) {
            $params = Util::getParams(func_get_args());
        }
        $this->_validates['uniqueness_of'][$field] = $params;
    }

    /**
     * Validates that certain attributes have a date format according to the one indicated in
     * config / config.ini before inserting or updating.
     *
     * @param string $field field to validate
     *
     * message: message to display
     * field: name of the field to display in the message
     */
    protected function validates_date_in($field, $params = array())
    {
        if (is_string($params)) {
            $params = Util::getParams(func_get_args());
        }
        $this->_validates['date_in'][$field] = $params;
    }

    /**
     * Verify if a field is a numeric data type or not.
     *
     * @param string $field
     *
     * @return bool
     */
    public function is_a_numeric_type($field)
    {
        return (strpos(' ' . $this->_data_type[$field], 'int') || strpos(' ' . $this->_data_type[$field], 'decimal') || strpos(' ' . $this->_data_type[$field], 'number'));
    }

    /**
     * Get the metadata data generated for the first time in the Session.
     *
     * @param string $table
     *
     * @return array
     */
    public static function get_meta_data($table)
    {
        if (isset(self::$models[$table])) {
            return self::$models[$table];
        }
        if (PRODUCTION) {
            $metadata = Cache::driver()->get($table, 'kumbia.models');
            if ($metadata) {
                return self::$models[$table] = unserialize($metadata);
            }
        }

        return array();
    }

    /**
     * Create a metadata record for the specified table.
     *
     * @param string $table
     * @param array  $meta_data
     */
    public static function set_meta_data($table, $meta_data)
    {
        if (PRODUCTION) {
            Cache::driver()->save(serialize($meta_data), Config::get('config.application.metadata_lifetime'), $table, 'kumbia.models');
        }
        self::$models[$table] = $meta_data;

        return true;
    }

    /** ******************************************************************************************
     * Methods for generating relationships.
     * ***************************************************************************************** */

    /**
     * Create a 1-1 relationship between two models.
     *
     * @param string $relation
     *
     * model: name of the model to which it refers
     * fk: field by which it is related (foreign key)
     */
    protected function has_one($relation)
    {
        $params = Util::getParams(func_get_args());
        for ($i = 0; isset($params[$i]); ++$i) {
            $relation = Util::smallcase($params[$i]);
            $index = explode('/', $relation);
            $index = end($index);
            if (!array_key_exists($index, $this->_has_one)) {
                $this->_has_one[$index] = new stdClass();
                $this->_has_one[$index]->model = isset($params['model']) ? $params['model'] : $relation;
                $this->_has_one[$index]->fk = isset($params['fk']) ? $params['fk'] : Util::smallcase(get_class($this)) . '_id';
            }
        }
    }

    /**
     * Create an inverse 1-1 relationship between two models.
     *
     * @param string $relation
     *
     * model: name of the model to which it refers
     * fk: field by which it is related (foreign key)
     */
    protected function belongs_to($relation)
    {
        $params = Util::getParams(func_get_args());
        for ($i = 0; isset($params[$i]); ++$i) {
            $relation = Util::smallcase($params[$i]);
            $index = explode('/', $relation);
            $index = end($index);
            if (!array_key_exists($index, $this->_belongs_to)) {
                $this->_belongs_to[$index] = new stdClass();
                $this->_belongs_to[$index]->model = isset($params['model']) ? $params['model'] : $relation;
                $this->_belongs_to[$index]->fk = isset($params['fk']) ? $params['fk'] : "{$relation}_id";
            }
        }
    }

    /**
     * Create a 1-n relationship between two models.
     *
     * @param string $relation
     *
     * model: name of the model to which it refers
     * fk: field by which it is related (foreign key)
     */
    protected function has_many($relation)
    {
        $params = Util::getParams(func_get_args());
        for ($i = 0; isset($params[$i]); ++$i) {
            $relation = Util::smallcase($params[$i]);
            $index = explode('/', $relation);
            $index = end($index);
            if (!array_key_exists($index, $this->_has_many)) {
                $this->_has_many[$index] = new stdClass();
                $this->_has_many[$index]->model = isset($params['model']) ? $params['model'] : $relation;
                $this->_has_many[$index]->fk = isset($params['fk']) ? $params['fk'] : Util::smallcase(get_class($this)) . '_id';
            }
        }
    }

    /**
     * Create an inverse n-n or 1-n relationship between two models.
     *
     * @param string $relation
     *
     * model: name of the model to which it refers
     * fk: field by which it is related (foreign key)
     * key: key field that identifies the model itself
     * through: through which table
     */
    protected function has_and_belongs_to_many($relation)
    {
        $params = Util::getParams(func_get_args());
        for ($i = 0; isset($params[$i]); ++$i) {
            $relation = Util::smallcase($params[$i]);
            if (!array_key_exists($relation, $this->_has_and_belongs_to_many)) {
                $this->_has_and_belongs_to_many[$relation] = new stdClass();
                $this->_has_and_belongs_to_many[$relation]->model = isset($params['model']) ? $params['model'] : $relation;
                $this->_has_and_belongs_to_many[$relation]->fk = isset($params['fk']) ? $params['fk'] : "{$relation}_id";
                $this->_has_and_belongs_to_many[$relation]->key = isset($params['key']) ? $params['key'] : Util::smallcase(get_class($this)) . '_id';
                if (isset($params['through'])) {
                    $this->_has_and_belongs_to_many[$relation]->through = $params['through'];
                }
            }
        }
    }

    /**
     * Simple inheritance
     */

    /**
     * Specifies that the class is the parent of another.
     *
     * @param string $parent
     */
    public function parent_of($parent)
    {
        $parents = func_get_args();
        foreach ($parents as $parent) {
            if (!in_array($parent, $this->parent_of)) {
                $this->parent_of[] = $parent;
            }
        }
    }

    /**
     * Eliminate characters that could help execute
     * an SQL Injection attack.
     *
     * @param string $sql_item
     */
    public static function sql_item_sanitize($sql_item)
    {
        $sql_item = trim($sql_item);
        if ($sql_item !== '' && $sql_item !== null) {
            $sql_temp = preg_replace('/\s+/', '', $sql_item);
            if (!preg_match('/^[a-zA-Z0-9_\.]+$/', $sql_temp)) {
                throw new KumbiaException('It is trying to execute a dangerous SQL!');
            }
        }

        return $sql_item;
    }

    /**
     * Eliminate characters that could help execute
     * an SQL Injection attack.
     *
     * @param string $sql_item
     */
    public static function sql_sanitize($sql_item)
    {
        $sql_item = trim($sql_item);
        if ($sql_item !== '' && $sql_item !== null) {
            $sql_temp = preg_replace('/\s+/', '', $sql_item);
            if (!preg_match('/^[a-zA-Z_0-9\,\(\)\.\*]+$/', $sql_temp)) {
                throw new KumbiaException('It is trying to execute a dangerous SQL!');
            }
        }

        return $sql_item;
    }

    /**
     * By overwriting this method you can control the exceptions of a model.
     *
     * @param unknown_type $e
     */
    protected function exceptions($e)
    {
        throw $e;
    }

    /**
     * Implementation of __toString Standard.
     */
    public function __toString()
    {
        return '<' . get_class($this) . ' Object>';
    }

    /**
     * Pager for the model.
     *
     * conditions: page conditions
     * page: number of page to display (default page 1)
     * per_page: number of items per page (default 10 items per page)
     *
     * @return un identical Page object that is returned with the paginate utility
     */
    public function paginate()
    {
        $args = func_get_args();
        array_unshift($args, $this);
        //if(!class_exists('Paginator')){
        require_once CORE_PATH . 'libs/kumbia_active_record/behaviors/paginate.php';
        //}
        return call_user_func_array(array('Paginator', 'paginate'), $args);
    }

    /**
     * Pager for the model through sql query.
     *
     * @param string $sql sql query
     *
     * page: number of page to display (default page 1)
     * per_page: number of items per page (default 10 items per page)
     *
     * @return un Identical Page object that is returned with the paginate_by_sql utility
     */
    public function paginate_by_sql($sql)
    {
        $args = func_get_args();
        array_unshift($args, $this);
        //if(!class_exists('Paginator')){
        require_once CORE_PATH . 'libs/kumbia_active_record/behaviors/paginate.php';
        //}
        return call_user_func_array(array('Paginator', 'paginate_by_sql'), $args);
    }

    /**
     * Serialization operations.
     *
     * */
    public function __sleep()
    {
        /*
         * Canceling connection to bd in the model
         * */
        $this->db = null;

        return array_keys(get_object_vars($this));
    }

    /**
     * Operations to deserialize.
     *
     * */
    public function __wakeup()
    {
        /*
         * Restoring bd connection
         * */
        $this->_connect();
    }

    /**
     * Get the instance of a model.
     *
     * @param string $model
     *
     * @return ActiveRecord
     * @throw KumbiaException
     * */
    public static function get($model)
    {
        /**
         * Class Name
         * */
        $Model = Util::camelcase($model);

        return new $Model();
    }

    /**
     * Returns a JSON of this model.
     *
     * @return string JSON of the model
     */
    public function to_json()
    {
        return json_encode($this);
    }

    /**
     * Returns an array of this model.
     *
     * @return array Model Array
     */
    public function to_array()
    {
        return (array) $this;
    }

    /**
     * Returns a PHP serial of this model
     * Use it carefully, as it passes all the attributes, not just the public.
     *
     * @return string PHP serial model
     */
    public function serialize()
    {
        return serialize($this);
    }
}
